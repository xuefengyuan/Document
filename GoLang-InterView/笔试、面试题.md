[TOC]

# 笔试、面试题

### 1、一致性哈希原理和它要解决的问题

> 哈希原理：一致性哈希算法简单来说就是一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用

>  解决的问题：一致性hash算法解决的核心问题是，当solt数发生变化的时候能够尽量少的移动数据。

### 2、C10K问题和解决方案

如果C10K就要创建1万个进程，那么操作系统是无法承受的。如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大。这就是C10K问题的本质。

解决这一问题，主要思路有两个：

> - 一个是对于每个连接处理分配一个独立的进程/线程；
> - 另一个思路是用同一进程/线程来同时处理若干连接。

> 参考该链接文档：https://blog.csdn.net/wangtaomtk/article/details/51811011

### 3、快速排序

```go
func QuickSort(array []int, start, end int) []int {
    if start < end {
        i, j := start, end
        // 取得关键值
        key := array[(start+end)/2]
        // 循环条件，左边下标大于等于右边下标
        for i <= j {
            // 从前往后比
            // 如果没有比关键值小的，比较下一个
            for array[i] < key {
                i++
            }
            // 从后往前比
            // 如果没有比关键值大的，比较下一个
            for array[j] > key {
                j--
            }
            // 判断下标，调换数据位置
            if i <= j {
                array[i], array[j] = array[j], array[i]
                i++
                j--
            }
        }
        // 此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
        if start < j {
            QuickSort(array, start, j)
        }
        if end > i {
            QuickSort(array, i, end)
        }
    }
    return array
}
```

### 4、冒泡排序

```go
func BubbleSort(array []int) []int {
    for i := 0; i < len(array)-1; i++ {
        for j := 0; j < len(array)-1-i; j++ {
            // 比较数据
            if array[j] < array[j+1] {
                // 数据位置调换
                array[j], array[j+1] = array[j+1], array[j]
            }
        }
    }
    return array
}
```

### 5、插入排序

```go
func InsertSort(array []int) []int {
    for i := 1; i < len(array); i ++ {
        for j := i; j > 0; j-- {
            if array[j-1] > array[j] {
                array[j-1], array[j] = array[j], array[j-1]
            }
        }
    }
    return array
}
```

### 6、什么是协程，Go的协程是如何实现的

协程：<font color=blue>是在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。</font>

> 协程和线程的原理是一样的，当 a线程 切换到 b线程 的时候，需要将 a线程 的相关执行进度压入栈，然后将 b线程 的执行进度出栈，进入 b线程 的执行序列。协程只不过是在 应用层 实现这一点。但是，协程并不是由操作系统调度的，而且应用程序也没有能力和权限执行 cpu 调度。
>
> 1. 怎么解决这个问题？
>
> 答案是：<font color=red>协程是基于线程的。内部实现上，维护了一组数据结构和 n 个线程，真正的执行还是线程，协程执行的代码被扔进一个待执行队列中，由这 n 个线程从队列中拉出来执行。这就解决了协程的执行问题。</font>
>
> 2. 那么协程是怎么切换的呢？
>
> 答案是：<font color=red>golang 对各种 io函数 进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步 io函数，当这些异步函数返回 busy 或 bloking 时，golang 利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。包括 linux 的 epoll、select 和 windows 的 iocp、event 等。</font>

### 7、什么是装饰器，请用装饰器实现singleton（单例模式）

<font color=blue>装饰器的本质是一个闭包函数，实现的功能是在不修改原函数及调用方式的情况下对原函数进行功能扩展的，是开放封闭原则的典型代表</font>

#### 7.1、实现singleton（单例模式）

7.1.1、懒汉模式（Lazy Loading）

懒汉模式是开源项目中使用最多的一种，最大的缺点是非线程安全的

```go
type singleton struct {
}
var instance *singleton
func GetInstance() *singleton {
    if instance == nil {
        instance = &singleton{}     // not thread safe
    }
    return instance
}
```

##### 7.1.2、带锁的单例模式

```go
type singleton struct {
}

var instance *singleton
var mu sync.Mutex

func GetInstance() *singleton {
    mu.Lock()
    defer mu.Unlock()
    if instance == nil {
        instance = &singleton{}   // unnecessary locking if instance already created
    }
    return instance
}
```

##### 7.1.3、 带检查锁的单例模式

```go
import "sync"
import "sync/atomic"
var initialized uint32
...
func GetInstance() *singleton {
    if atomic.LoadUInt32(&initialized) == 1 {
        return instance
    }
    mu.Lock()
    defer mu.Unlock()
    if initialized == 0 {
         instance = &singleton{}
         atomic.StoreUint32(&initialized, 1)
    }
    return instance
}
```

##### 7.1.4、比较好的一种方式sync.Once

```go
import ( "sync" )
type singleton struct {
}

var instance *singleton
var once sync.Once

func GetInstance() *singleton {
    once.Do(func() {
        instance = &singleton{}
    })
    return instance
}
```

### 8、select、poll、epool的原理和区别

详细的参考该链接文档：https://my.oschina.net/xianggao/blog/663655

<font color=red>**select 函数监视的文件描述符分3类**</font>，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

<font color=red>**poll本质上和select没有区别**</font>，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

<font color=red>**epoll支持水平触发和边缘触发**</font>，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。

> 1. 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
> 2. select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。

### 9、Go的垃圾回收机制

> <font color=red>三色标记清除垃圾收集器，外加辅助回收功能</font>

- go 语言在 1.3 以前，使用的是比较蠢的传统 Mark-Sweep 算法。 
- 1.3 版本进行了一下改进，把 Sweep 改为了并行操作。 
- 1.5 版本进行了较大改进，使用了三色标记算法。go 1.5 在源码中的解释是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器” 
- go 除了标准的三色收集以外，还有一个辅助回收功能，防止垃圾产生过快手机不过来的情况。这部分代码在 runtime.gcAssistAlloc 中。 
- 但是 golang 并没有分代收集，所以对于巨量的小对象还是很苦手的，会导致整个 mark 过程十分长，在某些极端情况下，甚至会导致 GC 线程占据 50% 以上的 CPU。 

### 10、写一个简单的GO socket编程

#### 10.1、客户端

```go
import (
    "net"
    "log"
    "fmt"
    "reflect"
    "io"
)

func main() {
    addr := "127.0.0.1:8080" //定义主机名
    conn,err := net.Dial("tcp",addr) //拨号操作，需要指定协议。
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(conn.RemoteAddr().String()) //最好是加上后面的String方法，因为他们的那些是不一样的哟·当然你打印的时候可以不加。
    fmt.Println(conn.LocalAddr())
    fmt.Println(reflect.TypeOf(conn.LocalAddr()))
    fmt.Println(reflect.TypeOf(conn.RemoteAddr().String()))
    n,err := conn.Write([]byte("GET / HTTP/1.1\r\n\r\n")) //向服务端发送数据。用n接受返回的数据大小，用err接受错误信息。
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("写入的大小是:",n)
    buf := make([]byte,10) // 定义一个切片的长度是1024。
    for  {
        n,err = conn.Read(buf) // 接收到的内容大小。
        if err == io.EOF {
            conn.Close()
        }
        fmt.Print(string(buf[:n]))
    }
    fmt.Println(string(buf[:n])) // 将接受的内容都读取出来。
}
```

#### 10.2、服务端(并发)

```go
import (
    "net"
    "time"
)
func Handle_conn(conn net.Conn) { // 这个是在处理客户端会阻塞的代码。
    conn.Write([]byte("test data\n"))
    time.Sleep(time.Minute)
    conn.Close() // 与客户端断开连接。
}
func main() {
    addr := "0.0.0.0:8080" // 表示监听本地所有ip的8080端口，也可以这样写：addr := ":8080"
    listener,err := net.Listen("tcp",addr)
    if err != nil {
        log.Fatal(err)
    }
    defer listener.Close()
    for  {
        conn,err := listener.Accept() // 用conn接收链接
        if err != nil {
            log.Fatal(err)
        }
        go Handle_conn(conn)  // 开启多个协程，不开多个线程把函数里的代码拿过来放这里就可以了
    }
}
```

### 11、迭代器和生成器以及他们之间的区别

- 迭代器就是用于迭代操作的的对象，遵从迭代协议（内部实现了__iter__()和__next__()方法，可以像列表（可迭代对象，只有__iter__()方法）一样迭代获取其中的值，与列表不同的是，构建迭代器的时候，不像列表一样一次性把数据加到内存，而是以一种延迟计算的方式返回元素，即调用next方法时候返回此值。

- 生成器本质上也是一个迭代器，自己实现了可迭代协议，与生成器不同的是生成器的实现方式不同，可以通过生成器表达式和生成器函数两种方式实现，代码更简洁。生成器和迭代器都是惰性可迭代对象，只能遍历一次，数据取完抛出Stopiteration异常

### 12、NGINX 负载均衡、反向代理、正向代理

链接详细文档：https://blog.csdn.net/tsummerb/article/details/79248015

<font color=red>**反向代理**</font> 主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息

> 多个客户端给服务器发送的请求，nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。

<font color=red>**正向代理**</font> 正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息

<font color=red>**负载均衡**</font> 将服务器接收到的请求按照规则分发的过程

> 负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种。
>
> - <font color=red>硬件负载均衡也称为硬负载：</font>相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障
>
> - <font color=red>软件负载均衡：</font>是利用现有的技术结合主机硬件实现的一种消息队列分发机制

### 13、分表分库

##### 13.1、分表

> 在分表之前，首先要选中合适的分表策略（以哪个字典为分表字段，需要将数据分为多少张表），使数据能够均衡的分布在多张表中，并且不影响正常的查询。在企业级应用中，往往使用org_id(组织主键)做为分表字段，在互联网应用中往往是userid。在确定分表策略后，当数据进行存储及查询时，需要确定到哪张表里去查找数据，
>
> <font color=red>数据存放的数据表 = 分表字段的内容 % 分表数量</font>

##### 13.2、分库

> 分表能够解决单表数据量过大带来的查询效率下降的问题，但是不能给数据库的并发访问带来质的提升，面对高并发的写访问，当Master无法承担高并发的写入请求时，不管如何扩展Slave服务器，都没有意义了。我们通过对数据库进行拆分，来提高数据库的写入能力，即所谓的分库。分库采用对关键字取模的方式，对数
>
> <font color=red>据库进行路由。     数据存放的数据库 = 分库字段的内容%数据库的数量</font>

##### 13.3、即分表又分库

> 数据库分表可以解决单表海量数据的查询性能问题，分库可以解决单台数据库的并发访问压力问题

当数据库同时面临海量数据存储和高并发访问的时候，需要同时采取分表和分库策略。一般分表分库策略如下：

> <font color=red>中间变量 = 关键字 %（数据库数量 * 单库数据表数量）</font>
>
> <font color=red>库 = 取整（中间变量 / 单库数据表数量）</font>
>
> <font color=red>表 = （中间变量 % 单库数据表数量）</font>

### 14、MySql如何优化

可以参考详细链接文档：https://coolshell.cn/articles/1846.html

#### 1）：为查询缓存优化你的查询

> 大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。

#### 2）：EXPLAIN 你的 SELECT 查询

> 使用 [EXPLAIN](http://dev.mysql.com/doc/refman/5.0/en/explain.html) 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。

#### 3）：当只要一行数据时使用 LIMIT 1

> 当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。
>
> 在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。

#### 4）：为搜索字段建索引

> 索引并不一定就是给主键或是唯一的字段，如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。另外也不是任何搜索都可以用索引的。比如在一个大文章搜索一个词时就需要使用[MySQL全文索引](http://dev.mysql.com/doc/refman/5.1/en/fulltext-search.html) 或是自己做一个索引

#### 5）：在Join表的时候使用相当类型的例，并将其索引

> 如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。
>
> 这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。

#### 6）： 千万不要 ORDER BY RAND()

> 如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）

#### 7）：避免 SELECT *

>  从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。

#### 8）：永远为每张表设置一个ID

> 应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。
>
> 只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。

#### 9）：使用 ENUM 而不是 VARCHAR

> [ENUM](http://dev.mysql.com/doc/refman/5.0/en/enum.html) 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。

#### 10）：从 PROCEDURE ANALYSE() 取得建议

> [PROCEDURE ANALYSE()](http://dev.mysql.com/doc/refman/5.0/en/procedure-analyse.html) 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。

#### 11）：尽可能的使用 NOT NULL

> 除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。
>
> 不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。

#### 12）：Prepared Statements

> Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。
>
> Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。
>
> 在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。
>
> 虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。

#### 13）：无缓冲的查询

> 正常的情况下，当你在当你在你的脚本中执行一个SQL语句的时候，你的程序会停在那里直到没这个SQL语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。

#### 14）：把IP地址存成 UNSIGNED INT

> 很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果用整形来存放，只需要4个字节，并且可以有定长的字段。而且，这会为查询上带来优势，尤其是当需要使用这样的WHERE条件：IP between ip1 and ip2。
>
> 必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。

#### 15）：固定长度的表会更快

> 固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。
>
> 并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。

#### 16）：垂直分割

> “垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。
>
> <font color=red>需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。</font>

#### 17）： 拆分大的 DELETE 或 INSERT 语句

> 如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。
>
> <font color=red>如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。</font>

#### 18）：越小的列会越快

> 对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。

#### 19）：选择正确的存储引擎

> 在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。
>
> MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。
>
> InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。

#### 20）：使用一个对象关系映射器（Object Relational Mapper）

> 使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。
>
> ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。
>
> ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。

#### 21）： 小心“永久链接”

> “永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。

### 15、redis类型组成 RDB和AOF

详细网络资源文档：https://blog.csdn.net/qwqw3333333/article/details/81389644

##### 15.1）：RDB

> 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，父进程是不用进行任何IO操作的，使Redis最大性能化。

##### 15.2）：AOF

> 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

### 16、mongodb 原子性

> mongodb在4.0版本之前不支持事务，在4.0版本之后提供了事务支持，在MongoDB中，一个写操作的原子性是基于单个文档的。
>
> 涉及多个文档的操作，通常被作为一个“事务”，而不是原子性的。因为文档可以是相当复杂并且包含多个嵌套文档，单文档的原子性对许多实际用例提供了支持。尽管单文档操作是原子性的，在某些情况下，需要多文档事务。在这些情况下，使用两阶段提交，提供这些类型的多文档更新支持。因为文档可以表示为Pending数据和状态，可以使用一个两阶段提交确保数据是一致的，在一个错误的情况下，事务前的状态是可恢复的。

### 17、消息队列使用场景

详细的参阅网络文档：https://www.cnblogs.com/ruiati/p/6649868.html

> 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性

#### 17.1）：异步处理

> 用户注册后，需要发注册邮件和注册短信。

#### 17.2）：应用解耦

> 用户下单后，订单系统需要通知库存系统。

#### 17.3）：流量削锋

> 流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛
>
> 应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。

#### 17.4）：消息通讯

> 消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等点对点通讯。

### 18、GoLang PProf

网络详细文档：https://www.jianshu.com/p/4e4ff6be6af9

>  pprof 是Golang原生提供的用于可视化和分析性能分析数据的工具

### 19、kafka和RabbitMQ的区别

网络文档详细讲解：https://soledede.iteye.com/blog/1974988

> <font color=red>Kafka是严格保证了消息队列的顺序，就是一个topic下面的一个分区内只能给一个消费者消费，对于一个分区来说，kafka是不支持并发，但是可以通过扩大分区实现并发</font>

> <font color=red>Rabbitmq 不承诺消息的顺序性，因此可以并发多线程处理。在队列中不必排队。如果对处理的顺序没有要求，就可以用Rabbitmq教容易的实现并发。</font>

### 20、工厂模式原理

> 定义一个用于创建对象的统一的接口，然后由子类实现。

4个核心角色

> 1. 抽象产品
> 2. 具体产品
> 3. 抽象工厂
> 4. 具体工厂

### 21、如何优化sql查询语句

优化查询效率，主要原则就是应尽量避免全表扫描，应该考虑在where及order by 涉及的列上建立索引。

建立索引不是建的越多越好，原则是：

- 第一：一个表的索引不是越多越好，也没有一个具体的数字，根据以往的经验，**一个表的索引最多不能超过6个，**因为索引越多，对update和insert操作也会有性能的影响，涉及到索引的新建和重建操作。

- 第二：建立索引的方法论为：
  1. 多数查询经常使用的列；
  2. 很少进行修改操作的列；
  3. 索引需要建立在数据差异化大的列上

### 22、缓存使用场景，分别用那些？过期原则

> <font color=red>更快读写的存储介质+减少IO+减少CPU计算=性能优化</font>

#### 22.1）：缓存使用场景

##### CPU缓存

> 是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。

##### 浏览器缓存

> 浏览器可以缓存一些静态资源，比如图片、js、css等，这些都是不常变化的内容，所以没有必要每次都去请求。

##### CDN缓存

> 客户端会先检查浏览器的缓存，若缓存过期则会像CDN发送请求(Request)，CDN检查缓存数据还未过期，那么直接返回响应（Response），只需两步搞定。但是，CDN缓存过期，那么需要向应用服务器（Web Server）发起请求，获得新的数据响应，这部分新的数据按一定的缓存策略会选择是否缓存在CDN中。


##### 数据库缓存

>提高访问速度：内存>>磁盘；减少磁盘IO的操作，减少重复查询，提高吞吐量

##### 业务层缓存

#### 22.2）：缓存产品用过哪些？(根据各自使用选择)

LinkedHashMap 和Ehcache都是单机缓存技术，即只能在一个应用内实现缓存，不能实现多台机器使用相同的缓存区域（分布式缓存）

##### Ehcache

> LinkedHashMap 只是一个JDK自带的类，而Ehcache是一个外部jar包，是java领域常用的缓存框架，鼎鼎大名的hibernate都是用Ehcache，但ehcache也可用使用某些技术支持在群集环境中使用

##### LinkedHashMap

> 的底层是用HashMap实现的，特点元素的排序是按链表方式排序，按写入或输出的顺序排序，最后一次写入或读取的元素放到最后

##### Redis

> Redis同样是分布式缓存技术，比Memcached更新，支持的数据类型更多，使用更方便，最重要的是：Memcached的数据只能存在内存中，重启后即消失，而Redis可以持久化，因此Redis可以作为一个NoSql数据库使用。

#### 22.3）：缓存过期原则

> - 淘汰最后使用时间距当前时间较长的数据
> - 淘汰某段时间内的使用频次较低的数据
> - 淘汰先写入的数据

### 23、Go的内存管理

> - 当一片内存没有指向它（可以找到它）的时候，就会被释放
> - 看内部是不是内存池，以及是在栈上分配还是堆上分配
> - go编译器其实对内存有管理，在编译时也会识别你这个是局部变量，退出函数就没了， 还是需要分配在堆上
> - 它识别是一个函数的局变量，肯定就在栈上使用，不用管分配
> - 如果在堆上，比如return &var，肯定就是在内存池中
> - 内存管理，无非就是防内存碎片

### 24、go的几种锁

#### 5.1、死锁

> <font color=red>死锁： 不是锁的一种！！！是一种错误使用锁导致的现象。</font>

1. 单go程自己死锁
   - channel 应该在 至少 2 个以上的 go程中进行通信。否则死锁！！！
2. go程间channel访问顺序导致死锁
   - 使用channel一端读（写）， 要保证另一端写（读）操作，同时有机会执行。否则死锁。
3. 多go程，多channel 交叉死锁
   - A go程，掌握M的同时，尝试拿N； B go程，掌握N的同时尝试拿M。 
4. 在go语言中，尽量不要将 互斥锁、读写锁 与 channel 混用。 ——  隐性死锁。

#### 5.2、互斥锁(互斥量)

每个资源都对应于一个可称为 "互斥锁" 的标记，这个标记用来保证在任意时刻，只能有一个协程（线程）访问该资源。其它的协程只能等待。

> - A 、B go程 共同访问共享数据。 由于cpu调度随机，需要对 共享数据访问顺序加以限定（同步）。
> - 创建 mutex（互斥锁），访问共享数据之前，加锁，访问结束，解锁。 在A go程加锁期间，B go程加锁会失败——阻塞。
> - 直至 A go程 解锁mutex，B 从阻塞处。恢复执行。

<font color=red>使用互斥锁时，一定要注意：对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。</font>

#### 5.3、读写锁

读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutine既不能进行读操作，也不能进行写操作。

GO中的读写锁由结构体类型sync.RWMutex表示。此类型的方法集合中包含两对方法：

一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”：

```go
func (*RWMutex)Lock()
func (*RWMutex)Unlock()
```

另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁”：

```go
func (*RWMutex)RLock()
func (*RWMutex)RUlock()
```

### 25、go rooutine 底层原理

goroutine的并发模型定义为以下几个要点：

> - 基于Thread的轻量级协程
> - 通过channel来进行协程间的消息传递
> - 只暴露协程，屏蔽线程操作的接口

> goroutine的本质是协程，是实现并行计算的核心。

Golang采取了一种多对多的方案。runtime默认的实现为M:N的模型，于是这样可以根据具体的操作类型（操作系统阻塞或非阻塞操作）调整goroutine和OS Thread的映射情况，显得更加的灵活。

### 26。Go有缓冲channel和无缓冲channel

<font color=red>无缓冲通道，一次只能传输一个数据</font>

无缓冲特性： 

> 同一时刻，同时有读、写两端把持 channel。 
> 如果只有读端，没有写端，那么 “读端”阻塞。 
> 如果只有写端，没有读端，那么 “写端”阻塞。

有缓冲特性：

> <font color=red>channel 中自带缓冲区。创建时可以指定缓冲区的大小。 </font>
> w：直到缓冲区被填满后，写端才会阻塞。 
> r：缓冲区被读空，读端才会阻塞。 
> len：代表缓冲区中，剩余元素个数， 
> cap：代表缓冲区的容量。 

### 27、 Rbac权限管理如何实现

详细的可以浏览网络文章：https://blog.csdn.net/yangwenxue_admin/article/details/73936803

> RBAC（Role-Based Access Control ）基于角色的访问控制。
>
> <font color=red>RBAC支持公认的安全原则：最小特权原则、责任分离原则和数据抽象原则。</font>

权限控制很多系统中都需要，但是不同的系统对于权限的敏感程度不同，因而权限的设计实现方式不同。

<font color=red>概要设计：</font> 

首先理一下，那些地方需要权限控制，分为以下几个模块： 

> 1. 系统登录，提供正确的用户名和密码才可以登录系统，未登录系统禁止访问其他界面。 
> 2. 系统主界面展示，根据用户的角色不同部门不同展示不同的菜单选项。 
> 3. 防止越过前台操作后台。比如脚本攻击，或者模拟客户端发送请求。 
> 4. 防止越权操作。（需要系统前后台做权限的校验）

### 28、订单超卖如何解决

#### 28.1）：前端

面对高并发的抢购活动，前端常用的三板斧是【扩容】【静态化】【限流】

　　**A：扩容：**加机器，这是最简单的方法，通过**增加前端池**的整体承载量来抗峰值。

　　**B：静态化：**将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。

　   **C：限流：**一般都会采用IP级别的限流，即针对某一个IP，限制单位时间内发起请求数量。或者活动入口的时候增加游戏或者问题环节进行消峰操作。

​      **D：有损服务：**最后一招，在接近前端池承载能力的水位上限的时候，随机拒绝部分请求来保护活动整体的可

#### 28.2）：后端

##### 1：解决方案1

> 将存库从**MySQL前移到Redis**中，所有的写操作放到内存中，由于Redis中不存在锁故不会出现互**相等待**，并且由于Redis的写性能和读性能都远高于MySQL，这就解决了高并发下的性能问题。然后通过**队列等异步手段**，将变化的数据异步**写入到DB中**。

- 优点：**解决性能问题**

- 缺点：没有解决超卖问题，同时由于异步写入DB，存在某一时刻DB和Redis中数据**不一致的风险**。

##### 2：解决方案2

> 引入队列，然后将所有**写DB操作在****\*单队列中排队**，完全串行处理*。当达到库存**阀值**的时候就不在消费队列，并**关闭购买功能**。这就解决了超卖问题。

- 优点：解决超卖问题，**略微提升性能**。

- 缺点：**性能受限于队列**处理机处理性能和DB的写入性能中最短的那个，另外**多商品**同时抢购的时候需要准备**多条队列**。

##### 3：解决方案3

> 将写操作前移到MC中，同时利用MC的轻量级的锁机制CAS来实现减库存操作。

- 优点：读写在内存中，操作性能快，引入轻量级锁之后可以保证同一时刻只有一个写入成功，解决减库存问题。

- 缺点：没有实测，基于CAS的特性不知道高并发下是否会出现大量更新失败？不过加锁之后肯定对并发性能会有影响。

##### 4：解决方案4

> 将提交操作变成两段式，先申请后确认。然后利用**Redis的原子自增操作**（相比较MySQL的自增来说没有空洞），同时利用Redis的事务特性来发号，保证拿到小于等于库存阀值的号的人都可以成功提交订单。然后数据异步更新到DB中。

- 优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。

- 缺点：由于异步写入DB，可能存在数据不一致。另可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单数并没有达到库存阀值。

##### 5：最终解决方案：

> 我们可以有条件有选择的**在读操作上加锁（即在select ...语句最后加上for update）**，比如可以对库存做一个判断，当**库存小于一个量时开始加锁**，让**购买者排队**，这样一来就解决了超卖现象。

#### 28.3）：总结

1. 前端三板斧【扩容】【限流】【静态化】
2. 后端两条路【内存】+【排队】

### 29、异步和同步的区别？场景有哪些？

> - 同步:发送一个请求,等待返回,然后再发送下一个请求 
> - 异步:发送一个请求,不等待返回,随时可以再发送下一个请求

同步可以避免出现死锁，读脏数据的发生。同步可以避免出现死锁，读脏数据的发生。

<font color=red>同步和异步最大的区别就在于。一个需要等待，一个不需要等待。 </font>

**使用场景**

<font color=red>**异步的使用场景：**</font>

1. 不涉及共享资源，或对共享资源只读，即非互斥操作
2. 没有时序上的严格关系
3. 不需要原子操作，或可以通过其他方式控制原子性
4. 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能
5. 不影响主线程逻辑

**异步的好处：**

> 1. 异步流程可以立即给调用方返回初步的结果。
> 2. 异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。
> 3. 异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。
> 4. 异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。

<font color=red>**同步的使用场景：不使用异步的时候**</font>

**同步的好处：**

> 1. 同步流程对结果处理通常更为简单，可以就近处理。
> 2. 同步流程对结果的处理始终和前文保持在一个上下文内。
> 3. 同步流程可以很容易捕获、处理异常。
> 4. 同步流程是最天然的控制过程顺序执行的方式。

### 30、手写一个递归函数

```go
package main
import "fmt"
func fact(n int) int {
    if n == 0 {
        return 0
    } else if n == 1 {
        return 1
    } else {
        return fib(n-1) + fib(n-2)
    }
}
func main() {
    fmt.Println(fact(10))
}
```

### 31、秒杀原理，并提供解决方案

详细可以查看网络文档：https://blog.csdn.net/cyy_zyd/article/details/81741751

> （1）低廉价格；（2）大幅推广；（3）瞬时售空；（4）一般是定时上架；（5）时间短、瞬时并发量高；

#### 31.1）：解决方案：

1. 将秒杀系统独立部署，甚至使用独立域名，使其与网站完全隔离。

2. 重新设计秒杀商品页面，不使用网站原来的商品详细页面，页面内容静态化，用户请求不需要经过应用服务。

3. 因为秒杀新增的网络带宽，必须和运营商重新购买或者租借。为了减轻网站服务器的压力`需要将秒杀商品页面缓存在CDN，同样需要和CDN服务商临时租借新增的出口带宽。

4. 为了避免用户直接访问下单页面URL，需要将改URL动态化，即使秒杀系统的开发者也无法在秒杀开始前访问下单页面的URL。办法是在下单页面URL加入由服务器端生成的随机数作为参数，在秒杀开始的时候才能得到。

5. 使用JavaScript脚本控制，在秒杀商品静态页面中加入一个JavaScript文件引用，该JavaScript文件中包含 秒杀开始标志为否；当秒杀开始的时候生成一个新的JavaScript文件（文件名保持不变，只是内容不一样），更新秒杀开始标志为是，加入下单页面的URL及随机数参数（这个随机数只会产生一个，即所有人看到的URL都是同一个，服务器端可以用redis这种分布式缓存服务器来保存随机数），并被用户浏览器加载，控制秒杀商品页面的展示。这个JavaScript文件的加载可以加上随机版本号（例如xx.js?v=32353823），这样就不会被浏览器、CDN和反向代理服务器缓存。

   这个JavaScript文件非常小，即使每次浏览器刷新都访问JavaScript文件服务器也不会对服务器集群和网络带宽造成太大压力。

6. **如何只允许第一个提交的订单被发送到订单子系统**

   由于最终能够成功秒杀到商品的用户只有一个，因此需要在用户提交订单时，检查是否已经有订单提交。如果已经有订单提交成功，则需要更新 JavaScript文件，更新秒杀开始标志为否，购买按钮变灰。事实上，由于最终能够成功提交订单的用户只有一个，为了减轻下单页面服务器的负载压力， 可以控制进入下单页面的入口，只有少数用户能进入下单页面，其他用户直接进入秒杀结束页面。

   **解决方案**：假设下单服务器集群有10台服务器，每台服务器只接受最多10个下单请求。在还没有人提交订单成功之前，如果一台服务器已经有十单了，而有的一单都没处理，可能出现的用户体验不佳的场景是用户第一次点击购买按钮进入已结束页面，再刷新一下页面，有可能被一单都没有处理的服务器处理，进入了填写订单的页面，可以考虑通过cookie的方式来应对，符合一致性原则。当然可以采用最少连接的负载均衡算法，出现上述情况的概率大大降低。

#### 31.2）：秒杀架构原则

1. **尽量将请求拦截在系统上游**

   传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】。

2. **读多写少的常用多使用缓存**

   这是一个典型的`读多写少`的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%】，`非常适合使用缓存`。

### 32、闭包原理

<font color=red>只有函数中的子函数才能引用函数中的变量，简单来说，闭包就是定义在函数中的函数，是函数内外部连接的桥梁</font>

**闭包的意义：**

1. 当前作用域总是能够访问外部作用域中的变量；
2. 函数是唯一拥有自身作用域的结构，所以闭包的创建依赖于函数

**闭包的两大作用：**

1. 内部function会访问外部函数的参数、变量、函数，
2. 将函数中的变量的值存储于内存中（不会被垃圾回收机制回收）

<font color=red>**使用闭包的注意点：**</font>

> 1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
> 2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

### 33、GoLang项目的性能分析

使用golang自带的ppro性能分析工具和uber的go-torch性能分析工具。

### 34、服务器性能出现瓶颈该如何检测

网络详细文档：https://blog.csdn.net/hbtianmimi/article/details/8517501

可以从以下几个方面进行分析

> 1. 内存分析：内存分析用于判断系统有无内存瓶颈，是否需要通过增加内存等手段提高系统性能。
> 2. 处理器分析：看System\%Total Processor Time 性能计数器的计数值。
> 3. 磁盘I/O分析：每磁盘的I/O数可用来与磁盘的I/O能力进行对比，如果经过计算得到的每磁盘I/O数超过了磁盘标称的I/O能力，则说明确实存在磁盘的性能瓶颈。。
> 4. 进程分析：查看进程的％Processor Time值
> 5. 网络分析：Network Interface\Bytes Total/sec为发送和接收字节的速率，可以通过该计数器值来判断网络链接速度是否是瓶颈

### 35、RPC原理

详细可参考两个网络文档：https://www.cnblogs.com/swordfall/p/8683905.html，https://www.cnblogs.com/metoy/p/4321311.html

**RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。** 为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。

<font color=red>**RPC架构**</font>

一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。

- 客户端(Client)，服务的调用方。
- 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
- 服务端(Server)，真正的服务提供者。
- 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

<font color=red>**RPC 调用分以下两种：**</font>

1. 同步调用
   - 客户方等待调用执行完成并返回结果。
2. 异步调用
   - 客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。 若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。

### 36、Redis哨兵原理

网络详细文档：https://blog.csdn.net/u012240455/article/details/81843714

Redis的哨兵(sentinel) 系统用于管理多个 Redis 服务器,该系统执行以下三个任务:
- <font color=red>**监控(Monitoring)**</font>: 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。
- <font color=red>**提醒(Notification)**</font>:当被监控的某个 Redis出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。
- <font color=red>**自动故障迁移(Automatic failover)**</font>:当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。

<font color=red>**哨兵(sentinel) 是一个分布式系统,你可以在一个架构中运行多个哨兵(sentinel) 进程**</font>,这些进程使用流言协议(gossipprotocols)来接收关于Master是否下线的信息,并使用投票协议(agreement protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。
​      <font color=blue>每个哨兵(sentinel) 会向其它哨兵(sentinel)、master、slave**定时**发送消息,以确认对方是否”活”着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机” Subjective Down,简称sdown).</font>
若“哨兵群”中的多数sentinel,都报告某一master没响应,系统才认为该master"彻底死亡"(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。
​     <font color=green> 虽然哨兵(sentinel) 释出为一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 --sentinel 选项来启动哨兵(sentinel)。</font>

<font color=red>**注意：**</font>

1. 当启动哨兵模式之后，如果你的master服务器宕机之后，哨兵自动会在从redis服务器里面 投票选举一个master主服务器出来；这个主服务器也可以进行**读写**操作！

2. 如果之前宕机的主服务器已经修好，可以正式运行了。那么这个服务器只能进行**读**的操作，会自动跟随由哨兵选举出来的新服务器！

### 37、如何实现多态

**实现多态的三种方法**：1、虚方法 2、抽象类 3、接口

<font color=red>**GoLang实现多态用的是接口**</font>

### 38、GoLang的继承

继承：<font color=red>表明了子对象和父对象之间的关系，子对象是对父对象的扩展，实际上，子对象“是”父对象。相当于说“码农是人”。从特征的集合这个意义上说，子对象包含父对象，父对象有的公共特征，子对象全都有。</font>

<font color=blue>GoLang中的继承是利用struct实现的。</font>

### 39、京东购物车原理

网络详情文章：https://www.cnblogs.com/shuai-server/p/8996625.html，https://www.cnblogs.com/wang-meng/p/5854773.html

两种情况：

> - 用户登录，购物车存入redis中
> - 用户未登录，购物车存入cookie中

cookie：<font color=blue>优点：数据保存在用户浏览器中，不占用服务端内存；用户体检效果好；代码实现简单</font>

　　　    <font color=red>缺点：cookie的存储空间只有4k；更换设备时，购物车信息不能同步；cookie禁用，不提供保存</font>

redis：<font color=blue>优点：数据能够持久化；实现了购物车同步</font>

　　　 <font color=red>缺点：增加了数据库的压力，速度慢</font>

<font color=blue>**cookie存储购物车的实现思路**</font>

> 1. 用户未登录状态下，用户添加购物车，首先从cookie中查询购物车中的商品列表
> 2. 判断cookie的商品列表中是否有要添加的商品信息
> 3. 如果cookie中有该商品信息，将商品的数量相加
> 4. 如果没有，根据商品的id值查询商品信息
> 5. 将商品添加到购物车列表中
> 6. 将购物车列表写入cookie中，设置cookie的过期时间
> 7. 将cookie返回给客户端。

<font color=red>**cookie删除购物车中商品**</font>

> 1. 接收页面传递的善品id值
> 2. 从cookie中取出购物车列表，进行循环遍历，然后遍历的每一个商品信息和要删除的商品进行对比
> 3. 如果存在就从购物车列表中将该商品移除
> 4. 重新将购物车列表写入cookie中
> 5. 将cookie信息响应给客户端

<font color=blue>**实现redis购物车添加功能**</font>

> 1. 从request域中取出登录用户的信息
> 2. 使用redis存储购物车列表 使用redis中的hash数据类型  hash的key 使用登录用户id值，field的key使用商品的id值，将商品的信息作为field的value值
> 3. 完成cookie存储购物车列表的功能

### 40、数据库读写分离，主从同步如何实现

网络文章链接：https://www.cnblogs.com/0zcl/p/7141459.html，https://blog.csdn.net/qq_15092079/article/details/81672920

**主从同步**

在多个服务器上部署mysql，将其中一台认为主数据库，而其他为从数据库，实现主从同步。其中主数据库负责主动写的操作，而从数据库则只负责主动读的操作（slave从数据库仍然会被动的进行写操作，为了保持数据一致性），这样就可以很大程度上的避免数据丢失的问题，同时也可减少数据库的连接，减轻主数据库的负载。

<font color=red>**主从同步复制有以下几种方式：**</font>

1. 同步复制，master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。

2. 异步复制，master只需要完成自己的数据库操作即可，至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。

3. 半同步复制，master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MYSQL引入的。

<font color=blue>**读写分离**</font>

<font color=red>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。</font>

读写分离可以通过程序来实现。

- 可以在主服务器创建一个数据库用户（出于安全，根据需求给予相应的权限）主要用于写操作，在程序中通过这一用户连接主数据库的只用于写操作而不用读操作。

- 在从服务器上创建一个数据库用户（出于安全，只给予读select的权限）主要用于读操作，在程序中通过这一用户连接从数据库即可。

- 也可以找一个组件来完成MYSQL的代理，实现SQL语句的路由，这样就不需要我们在程序上关注哪个数据库是写，哪个数据库是读的了。

### 41、面向过程编程，面向对象编程和面向切面编程

网络文章详情：https://blog.csdn.net/small_mouse0/article/details/62895790

#### 41.1）：面向过程

(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。

#### 41.2）：面向对象编程

（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。

#### 41.3）：面向切面编程

（Aspect Oriented Programming(AOP)），是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。

### 42、beego过滤器的作用

可以根据指定的匹配规则在特定的项目运行阶段去执行自定义函数，函数一般放在beego.router()之前 。

```go
beego.InsertFilter(pattern string, position int, filter FilterFunc, params ...bool)
```

pattern 路由规则，可以根据一定的规则进行路由，如果你全匹配可以用 *

position 执行Filter 的地方，五个固定参数如下，分别表示不同的执行过程

> a)   BeforeStatic 静态地址之前
>
> b)   BeforeRouter 寻找路由之前
>
> c)    BeforeExec 找到路由之后，开始执行相应的 Controller 之前
>
> d)   AfterExec 执行完 Controller 逻辑之后执行的过滤器
>
> e)   FinishRouter 执行完逻辑之后执行的过滤器

过滤器函数格式，<font color=red>参数必须是context.Context</font>

```go
type FilterFunc func(*context.Context)
```

### 43、beego的字段自动验证功能如何实现

<font color=red>用的是结构体的附属字段标签（结构体自定义标签）</font>

结构体的字段不仅有名字与类型，还有一个可选的附属字段的标签(tag)

作用：**用于文档说明或者开发过程中的特殊标记。----大多数情况都是都是用于特殊标记**

**特殊标记**： 根据开发场景有特殊的作用（**结构体自定义标签**）

> 使用场景：
>
> ​	<font color=blue>ORM（Object-relational mapping）--结构体映射数据库</font>
>
> ​	<font color=blue>数据验证：Beego中的form表单数据--数据验证</font>
>
> ​	<font color=blue>序列化与反序列化：JSON模块--结构体转JSON字符串，json字符串转结构体</font>

**实现机制核心**

1. 自定义结构体标签，使用valid标签作为标志
2. 抽取不同字段的验证方法，例如数字类型字段验证方法，字符类型的验证方法，邮箱类型的验证方法等
3. 动态解析不同的字段调用对应字段的验证方法，并返回结果。

### 44、rest api接口实现原理

<font color=red>rest api 利用现有的http协议来实现。核心概念就是“资源+操作”的api。</font>

**何为资源**：资源就是一个Url

**何为操作**：操作包括 对资源的增删改查操作。

示例：

> 对资源 http://www.bupt.edu.cn/stu201311
>
> 1. 发出POST请求，表示增加学生stu201311
> 2. 发出PUT请求，表示修改学生stu201311的信息，例如修改学生的姓名
> 3. 发出DELETE请求，表示删除学生stu201311的信息
> 4. 发出GET请求，表示查看学生stu201311的信息

<font color=red>**总结，看一个标准的restful api要可以做到**</font>

> 看Url就知道要操作的资源是什么，是操作车辆还是围栏
> 看Http Method就知道操作动作是什么，是添加（post）还是删除（delete）
> 看Http Status Code就知道操作结果如何，是成功（200）还是内部错误（500）

### 45、如何实现对以往订单数据的统计

一般是用定时脚本每天定时跑脚本统计并写入数据库。新建年、月、天表，天表，每天12点以后跑，月表下个月第一天跑。

### 46、遍历目录下所有的文件夹

```go
func GetAllFile(pathname string) error {
    rd, err := ioutil.ReadDir(pathname)
    for _, fi := range rd {
        if fi.IsDir() {
            fmt.Printf("[%s]\n", pathname+"\\"+fi.Name())
            GetAllFile(pathname + fi.Name() + "\\")
        } else {
            fmt.Println(fi.Name())
        }
    }
    return err
}
```

### 47、GoLang的Map是否是并发安全，怎么解决？使用Map时需要注意什么问题？

<font color=red>golang的Map不是并发安全的</font>，解决Map并发安全问题可以定义一个结构体嵌套一个Map增加一个读写锁sync.RWMutex。

```go
type MyMap struct {
    v map[string]string
    sync.RWMutex
}
func (this *MyMap)Put(key string,value string)  {
    this.Lock()
    defer this.Unlock()
    this.v[key]=value
}
func (this *MyMap)Get(key string) string {
    this.RLock()
    defer   this.RUnlock()
    return this.v[key]
}
```

**使用Map需要注意什么**

> 1. 注意初始化问题
> 2. 指定初始化的容量（这里可以考虑到性能，一次创建足够大的map），不指定长度也可以，map会自动扩大
> 3. map传递的是引用，就是说形参会改变实参的值
> 4. map是无序的， 循环的时候不是真正的随机乱序取值, 这里不能作为随机取值来使用

### 48、切片的底层结构

详细信息参考网线链接：https://studygolang.com/articles/9876，https://www.cnblogs.com/bonelee/p/6862377.html

<font color=red>**注意 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针!!**</font>

49、GoLang 实现循环交叉打印不同数据如A、B、C、D、E

```go
func main() {
    chA := make(chan string)
    chB := make(chan string)
    chC := make(chan string)
    go func() {
        for {
            <-chA
            chA <- "A"
        }
    }()
    go func() {
        for {
            <-chB
            chB <- "B"
        }
    }()
    go func() {
        for {
            <-chC
            chC <- "C"
        }
    }()
    var isSend = false
    for {
        if !isSend {
            chA <- "A"
            isSend = true
        }
        select {
        case data := <-chA:
            fmt.Println(data)
            chB <- "B"
        case data := <-chB:
            fmt.Println(data)
            chC <- "C"
        case data := <-chC:
            fmt.Println(data)
            chA <- "A"
        }
    }
}
```





